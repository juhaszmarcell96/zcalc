<!DOCTYPE html>
<html>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* Prevent scrollbars */
        width: 100%;
        height: 100%;
    }
    
    canvas {
        display: block; /* Prevents extra space below canvas */
    }
</style>
<body>


<canvas id="playground" width="1800" height="1000" style="border:1px solid #d3d3d3;">no canvas support</canvas>
<canvas id="menu" width="1800" height="1000" style="border:1px solid #d3d3d3;">no canvas support</canvas>

<script src="./src/defines.js"></script>
<script src="./src/button.js"></script>
<script src="./src/component.js"></script>
<script src="./src/terminal.js"></script>
<script src="./src/source.js"></script>
<script src="./src/loads/lamp.js"></script>
<script src="./src/loads/motor.js"></script>
<script src="./src/switches/s101.js"></script>
<script src="./src/switches/s102.js"></script>
<script src="./src/switches/s106.js"></script>
<script src="./src/switches/stime.js"></script>
<script src="./src/switches/scontactor.js"></script>
<script src="./src/jbox.js"></script>
<script src="./src/wire.js"></script>
<script>
    class CScene {
        screen_to_canvas (x, y) {
            return {
                x: (x - this.offset_x) / this.scale,
                y: (y - this.offset_y) / this.scale
            };
        }

        get_component_at(x, y) {
            return this.components.find(component => component.is_inside(x, y));
        }

        get_terminal_at(x, y) {
            for (const component of this.components){
                let terminal = component.get_terminal_at(x, y);
                if (terminal) { return terminal; }
            }
            return null;
        }

        constructor (canvas) {
            this.canvas = canvas;
            this.context = canvas.getContext('2d');
            this.scale = 1.0;
            this.offset_x = 0.0;
            this.offset_y = 0.0;
            this.selected = null;
            this.panning = false;
            this.dragging = false;
            this.last_x = 0.0;
            this.last_y = 0.0
            this.components = [];
            this.new_wire = null;
            this.wire_type = WireType.L;

            canvas.addEventListener("wheel", (event) => {
                const { x, y } = this.screen_to_canvas(event.clientX, event.clientY);
                const zoomFactor = 1.1;
                
                if (event.deltaY < 0) { // Zoom in
                    this.scale *= zoomFactor;
                }
                else { // Zoom out
                    this.scale /= zoomFactor;
                }
            
                // Adjust offset to zoom towards cursor
                this.offset_x = event.clientX - x * this.scale;
                this.offset_y = event.clientY - y * this.scale;
            
                this.redraw();
                event.preventDefault();
            });
            canvas.addEventListener("mousedown", (event) => {
                const { x, y } = this.screen_to_canvas(event.clientX, event.clientY);
                this.last_x = event.clientX;
                this.last_y = event.clientY;
            
                if (event.button === 0) { // Left click (select object)
                    const terminal = this.get_terminal_at(x, y);
                    if (terminal) {
                        this.new_wire = new CWire(this.wire_type);
                        this.new_wire.start(terminal.get_middle_x(), terminal.get_middle_y());
                        this.mode = Mode.Wire;
                    }
                    else {
                        this.selected = this.get_component_at(x, y);
                        if (this.selected) {
                            this.dragging = true;
                        }
                    }
                }
                else if (event.button === 1) { // Middle click (pan)
                    this.panning = true;
                }
                event.preventDefault();
            });
            canvas.addEventListener("mousemove", (event) => {
                const { x, y } = this.screen_to_canvas(event.clientX, event.clientY);
                
                if (this.new_wire) {
                    this.new_wire.wire(x, y);
                }
                else if (this.dragging && this.selected) {
                    this.selected.move((event.clientX - this.last_x) / this.scale, (event.clientY - this.last_y) / this.scale);
                }
                else if (this.panning) {
                    this.offset_x += event.clientX - this.last_x;
                    this.offset_y += event.clientY - this.last_y;
                }
                
                this.last_x = event.clientX;
                this.last_y = event.clientY;
                this.redraw();
            });
            canvas.addEventListener("mouseup", () => {
                this.dragging = false;
                this.panning = false;
                this.selected = null;
                const { x, y } = this.screen_to_canvas(event.clientX, event.clientY);
                if (this.new_wire) {
                    this.new_wire.stop(x, y);
                    this.components.push(this.new_wire);
                    this.new_wire = null;
                    this.mode = Mode.Visual;
                }
            });
            canvas.addEventListener("contextmenu", (event) => {
                const { x, y } = this.screen_to_canvas(event.clientX, event.clientY);
                const index = [...this.components].reverse().findIndex(component => component.is_inside(x, y));
                if (index !== -1) {
                    this.components.splice(this.components.length - 1 - index, 1);
                }
                event.preventDefault();
                this.redraw();
            });


            this.mode = Mode.Visual;
        }

        draw_cursor_helper () {
            /* draw cursor */
            this.context.beginPath();
            this.context.lineWidth = (grid_size / 5) * 2;
            this.context.moveTo(0, this.mouse_y - (this.mouse_y % grid_size));
            this.context.lineTo(this.canvas.width, this.mouse_y - (this.mouse_y % grid_size));
            this.context.moveTo(this.mouse_x - (this.mouse_x % grid_size), 0);
            this.context.lineTo(this.mouse_x - (this.mouse_x % grid_size), this.canvas.height);
            this.context.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            this.context.stroke();
            this.context.closePath();
        }

        draw_cursor_delete () {
            /* draw cursor */
            this.context.beginPath();
            this.context.lineWidth = (grid_size / 5) * 2;
            this.context.moveTo(this.mouse_x - (2 * grid_size), this.mouse_y - (2 * grid_size));
            this.context.lineTo(this.mouse_x + (2 * grid_size), this.mouse_y + (2 * grid_size));
            this.context.moveTo(this.mouse_x - (2 * grid_size), this.mouse_y + (2 * grid_size));
            this.context.lineTo(this.mouse_x + (2 * grid_size), this.mouse_y - (2 * grid_size));
            this.context.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            this.context.stroke();
            this.context.closePath();
        }

        handle_mouse_move_event (event) {
            var rect = this.canvas.getBoundingClientRect();
            this.mouse_x = event.clientX - rect.left;
            this.mouse_y = event.clientY - rect.top;
            if (this.middleButtonDown) {
                for (let i = 0; i < this.components.length; i++) {
                    this.components[i].move(this.mouse_x, this.mouse_y);
                    this.redraw();
                }
            }
            else {
                //console.log(mouse_x + " " + mouse_y);
                switch (this.mode) {
                    case Mode.Visual : {
                        break;
                    }
                    case Mode.Wire : {
                        this.redraw();
                        if (this.wiringPhase == 2) {
                            this.newWire.set_last_pos (this.mouse_x, this.mouse_y);
                            this.newWire.draw(this.context);
                        }
                        this.draw_cursor_helper();
                        break;
                    }
                    case Mode.Delete : {
                        this.redraw();
                        this.draw_cursor_delete();
                        break;
                    }
                    case Mode.Move : {
                        if (this.selected != null) {
                            this.selected.move(this.mouse_x, this.mouse_y);
                            this.redraw();
                        }
                        break;
                    }
                    default : {
                        console.log('ERROR : unknown mode')
                    }
                }
            }
        }

        handle_mouse_click_event (event) {
            var rect = this.canvas.getBoundingClientRect();
            this.mouse_x = event.clientX - rect.left;
            this.mouse_y = event.clientY - rect.top;
            //console.log(mouse_x + " " + mouse_y);
            if (this.escButton.is_inside(this.mouse_x, this.mouse_y)) {
                this.mode = Mode.Visual;
                this.redraw();
                return;
            }
            if (this.lWireButton.is_inside(this.mouse_x, this.mouse_y)) {
                this.mode = Mode.Wire;
                this.wiringPhase = 1;
                this.wireType = WireType.L;
                this.redraw();
                return;
            }
            if (this.nWireButton.is_inside(this.mouse_x, this.mouse_y)) {
                this.mode = Mode.Wire;
                this.wiringPhase = 1;
                this.wireType = WireType.N;
                this.redraw();
                return;
            }
            if (this.peWireButton.is_inside(this.mouse_x, this.mouse_y)) {
                this.mode = Mode.Wire;
                this.wiringPhase = 1;
                this.wireType = WireType.PE;
                this.redraw();
                return;
            }
            if (this.delButton.is_inside(this.mouse_x, this.mouse_y)) {
                this.mode = Mode.Delete;
                this.redraw();
                return;
            }
            if (this.moveButton.is_inside(this.mouse_x, this.mouse_y)) {
                this.mode = Mode.Move;
                this.selected = null;
                this.redraw();
                return;
            }
            switch (this.mode) {
                case Mode.Visual : {
                    for (let i = 0; i < this.components.length; i++) {
                        if (this.components[i].is_inside(this.mouse_x, this.mouse_y)) this.components[i].do_stuff();
                    }
                    this.redraw();
                    break;
                }
                case Mode.Wire : {
                    if (this.wiringPhase == 1) {
                        var selectedTerminal = null;
                        for (let i = 0; i < this.components.length; i++) {
                            selectedTerminal = this.components[i].get_terminal_at(this.mouse_x, this.mouse_y);
                            if (selectedTerminal !== null) { 
                                this.mode = Mode.Wire;
                                this.newWire = new CWire(selectedTerminal.x + selectedTerminal.w / 2, selectedTerminal.y + selectedTerminal.h / 2, this.wireType);
                                this.newWire.T1 = selectedTerminal;
                            }
                        }
                        this.redraw();
                        this.wiringPhase = 2;
                    }
                    else if (this.wiringPhase == 2) {
                        for (let i = 0; i < this.components.length; i++) {
                            var selectedTerminal = this.components[i].get_terminal_at(this.newWire.get_last_pos_x(), this.newWire.get_last_pos_y());
                            if (selectedTerminal !== null) { 
                                this.mode = Mode.Visual;
                                this.newWire.set_last_pos (this.mouse_x, this.mouse_y);
                                this.newWire.T2 = selectedTerminal;
                                this.wires.push(this.newWire);
                                this.redraw();
                                this.wiringPhase = 0;
                                return;
                            }
                        }
                        this.newWire.fix_last_pos(this.mouse_x, this.mouse_y);
                        this.redraw();
                        this.draw_cursor_helper();
                        this.newWire.draw(this.context);
                    }
                    break;
                }
                case Mode.Delete : {
                    for (let i = 0; i < this.wires.length; i++) {
                        if (this.wires[i].is_inside(this.mouse_x, this.mouse_y)) {
                            this.wires.splice(i, 1);
                            this.mode = Mode.Visual;
                            this.redraw();
                            return;
                        }
                    }
                    this.redraw();
                    this.draw_cursor_delete();
                    break;
                }
                case Mode.Move : {
                    if (this.selected == null) {
                        for (let i = 0; i < this.components.length; i++) {
                            if (this.components[i].is_inside(this.mouse_x, this.mouse_y)) {
                                this.selected = this.components[i];
                                this.selected.start_move(this.mouse_x, this.mouse_y);
                                break;
                            }
                        }
                    }
                    else {
                        this.selected = null;
                    }
                    break;
                }
                default : {
                    console.log('ERROR : unknown mode ' + this.mode);
                }
            }
        }

        start_move () {
            var rect = this.canvas.getBoundingClientRect();
            this.mouse_x = event.clientX - rect.left;
            this.mouse_y = event.clientY - rect.top;
            for (let i = 0; i < this.components.length; i++) {
                this.components[i].start_move(this.mouse_x, this.mouse_y);
            }
        }

        redraw () {
            //console.log("redraw");
            this.context.setTransform(this.scale, 0, 0, this.scale, this.offset_x, this.offset_y);
            this.context.clearRect(-this.offset_x / this.scale, -this.offset_y / this.scale, this.canvas.width / this.scale, this.canvas.height / this.scale);
            this.components.forEach(component => {
                component.draw(this.context);
            });
            if (this.new_wire) {
                this.new_wire.draw(this.context);
            }
            if (this.mode == Mode.Wire) {
                this.draw_cursor_helper();
            }
        }

    };



    var playground = document.getElementById('playground');
    var menu = document.getElementById('menu');
    //canvas.width = document.body.clientWidth;
    //canvas.height = document.body.clientHeight / 2;
    menu.style.position = 'absolute';
    menu.style.left = 0 + 'px';
    menu.style.top = 0 + 'px';
    playground.width = 3.0/4.0 * window.innerWidth;
    playground.height = window.innerHeight;

    menu.style.position = 'absolute';
    menu.style.left = 3.0/4.0 * window.innerWidth + 'px';
    menu.style.top = 0 + 'px';
    menu.width = 1.0/4.0 * window.innerWidth;
    menu.height = window.innerHeight;
    
    var scene = new CScene(playground);
    var menuScene = new CScene(menu);


    scene.components.push(new CSource(2 * grid_size, 20 * grid_size));

    scene.components.push(new CJunctionBox(20 * grid_size, 100 * grid_size));
    scene.components.push(new CJunctionBox(100 * grid_size, 100 * grid_size));
    scene.components.push(new CJunctionBox(180 * grid_size, 100 * grid_size));
    scene.components.push(new CJunctionBox(260 * grid_size, 100 * grid_size));

    scene.components.push(new CLamp(120 * grid_size, 20 * grid_size));
    scene.components.push(new CLamp(180 * grid_size, 20 * grid_size));
    scene.components.push(new CLamp(240 * grid_size, 20 * grid_size));
    scene.components.push(new CLamp(300 * grid_size, 20 * grid_size));

    scene.components.push(new CSwitch101(20 * grid_size, 150 * grid_size));
    scene.components.push(new CSwitch101(100 * grid_size, 150 * grid_size));
    var timeSwitch = new CTimeSwitch(180 * grid_size, 150 * grid_size);
    scene.components.push(timeSwitch);
    scene.components.push(new CSwitch102(260 * grid_size, 150 * grid_size));
    scene.components.push(new CSwitch106(320 * grid_size, 100 * grid_size));
    scene.components.push(new CSwitch106(320 * grid_size, 150 * grid_size));

    scene.components.push(new C3PhaseMotor(120 * grid_size, 70 * grid_size));
    scene.components.push(new CContactor(50 * grid_size, 70 * grid_size));

    function timeElapsed () {
        timeSwitch.do_stuff();
        scene.redraw();
    }

    scene.redraw();
    menuScene.redraw();

    menu.addEventListener('click', function(evt) {
        menuScene.handle_mouse_click_event(evt);
    }, false);
/*
    document.addEventListener('keydown', (event) => {
        //var name = event.key;
        //var code = event.code;
        scene.handle_key_press_event(event.key);
    }, false);
*/
</script> 

</body>
</html>